package it.polimi.ingsw.server.model.gamecontext.market;

import it.polimi.ingsw.server.model.gameitems.GameItemsManager;
import it.polimi.ingsw.server.model.gameitems.MarbleColour;
import it.polimi.ingsw.server.model.gameitems.ResourceType;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import java.util.Random;

import static org.junit.jupiter.api.Assertions.*;

@ExtendWith(MockitoExtension.class)
class MarketTest {

    @Mock
    GameItemsManager gameItemsManager;

    Map<MarbleColour,Integer> test21marbles;

    @BeforeEach
    void setUp() {
        test21marbles = Map.of(
            new MarbleColour(
                "RedMarble", gameItemsManager, Optional.of(ResourceType.SERVANTS), 1, false
            ), 8,
            new MarbleColour(
                "BlueMarble", gameItemsManager, Optional.of(ResourceType.COINS), 0, false
            ), 5,
            new MarbleColour(
                "YellowMarble", gameItemsManager, Optional.of(ResourceType.STONES), 0, false
            ), 3,
            new MarbleColour(
                "AnotherBoringColorMarble", gameItemsManager, Optional.empty(), 0, true
            ), 5
        );
    }

    /**
     * Tests Market initialization.
     * Initializes the dimensions of the Market, creates a Map of Marbles, invokes the Market constructor passing
     * the Map and the dimensions of the Market as parameters; then gets the Marbles from the Market, counts them
     * and compares them to the ones put in the first Map.
     */
    @Test
    void testMarketInitialization() throws WrongNumberOfMarblesException {
        int nRow = 2;
        int nColumn = 3;
        Map<MarbleColour,Integer> marbles = new HashMap<>();
        marbles.put(new MarbleColour("RedMarble", gameItemsManager, Optional.of(ResourceType.SERVANTS), 1, false),5);
        marbles.put(new MarbleColour("GreyMarble", gameItemsManager, Optional.of(ResourceType.SHIELDS), 0, false),2);
        Market market = new Market(nRow, nColumn, marbles);
        assertNotNull(market.getMarbleMatrix());
        assertEquals(nRow,market.getMarbleMatrix().length);
        assertEquals(nColumn, market.getMarbleMatrix()[0].length);
        Map<MarbleColour,Integer> marblesTest = new HashMap<>();
        for(int i=0; i<nRow; i++)
            for(int j=0; j<nColumn; j++)
                marblesTest.compute(market.getMarbleMatrix()[i][j], (k, v) -> v!=null ? v+1 : 1);
        marblesTest.compute(market.getOutMarble(), (k, v) -> v!=null ? v+1 : 1);
        assertEquals(marbles, marblesTest);
    }

    /**
     * Tests Market initialization passing to the constructor a wrong number of Marbles, not equal to nRows*nColumns+1.
     * Initializes the dimensions of the Market, creates a Map of Marbles (the sum of the Marbles does not equal
     * the size of the Market), invokes the Market constructor and expects the Exception to be thrown.
     */
    @Test
    void testMarketInitializationWrongNumberOfMarbles() throws WrongNumberOfMarblesException {
        int nRow = 2;
        int nColumn = 3;
        Map<MarbleColour,Integer> marbles = new HashMap<>();
        marbles.put(new MarbleColour("RedMarble", gameItemsManager, Optional.of(ResourceType.SERVANTS), 1, false), 3);
        marbles.put(new MarbleColour("GreyMarble", gameItemsManager, Optional.of(ResourceType.SHIELDS), 0, false), 3);
        assertThrows(
            WrongNumberOfMarblesException.class,
            () -> new Market(nRow, nColumn, marbles),
            "If the number of given marbles is not equal to nRow * nColumn + 1 an exception should be thrown"
        );
    }

    /**
     * Tests Market initialization passing to the constructor a specific type of random number generator.
     * Checks the equality between Markets generated by the same seed (passed to the random number generator)
     * and the inequality between Markets generated by different seeds.
     * Checks also the equality (inequality) of Marbles on the slide, left outside the Market.
     */

    @Test
    void testMarketInitializationRandomness() throws WrongNumberOfMarblesException {
        int nRow = 4;
        int nCol = 5;
        Market market1 = new Market(new Random(1), nRow, nCol, test21marbles);
        Market market1Copy = new Market(new Random(1), nRow, nCol, test21marbles);
        Market market2 = new Market(new Random(2), nRow, nCol, test21marbles);
        assertTrue(marbleMatricesEquals(market1.getMarbleMatrix(), market1Copy.getMarbleMatrix()));
        assertEquals(market1.getOutMarble(), market1Copy.getOutMarble());
        assertFalse(marbleMatricesEquals(market1.getMarbleMatrix(), market2.getMarbleMatrix()));
        assertNotEquals(market1.getOutMarble(), market2.getOutMarble());
    }

    /**
     * Tests the fetch of a specific Marble row in the Market.
     * Initializes the Market, invokes the fetch of a chosen row of the Market, verifies that the method returns
     * a copy of the Marbles selected and shifts the position of the Marbles in the Matrix.
     */
    @Test
    void testFetchMarbleRow() throws IllegalArgumentException, WrongNumberOfMarblesException {
        int nRows = 5, nColumns = 4;
        Market market = new Market(nRows, nColumns, test21marbles);
        MarbleColour[][] oldMatrix = market.getMarbleMatrix();
        MarbleColour oldOutMarble = market.getOutMarble();
        int chosenRow = 2;
        assertArrayEquals(oldMatrix[chosenRow], market.fetchMarbleRow(chosenRow));
        assertEquals(oldMatrix[chosenRow][0], market.getOutMarble());
        for (int i = 0; i < nColumns - 1; i++) {
            assertEquals(oldMatrix[chosenRow][i+1], market.getMarbleMatrix()[chosenRow][i]);
        }
        assertEquals(oldOutMarble, market.getMarbleMatrix()[chosenRow][nColumns-1]);
    }

    /**
     * Tests the fetch of a specific Marble row in the Market if the row passed as parameter is negative
     * or if it's greater than the number of rows of the Market matrix.
     */
    @Test
    void testFetchMarbleRowIllegalArgument() throws IllegalArgumentException, WrongNumberOfMarblesException {
        int nRows = 5, nColumns = 4;
        Market market = new Market(nRows, nColumns, test21marbles);
        int chosenWrongRow = 5;
        assertThrows(IllegalArgumentException.class, () -> market.fetchMarbleRow(chosenWrongRow));
        int chosenNegativeRow = -1;
        assertThrows(IllegalArgumentException.class, () -> market.fetchMarbleRow(chosenNegativeRow));
    }

    /**
     * Tests the fetch of a specific Marble column in the Market.
     * Initializes the Market, invokes the fetch of a chosen column of the Market, verifies that the method returns
     * a copy of the Marbles selected and shifts the position of the Marbles in the Matrix.
     */
    @Test
    void testFetchMarbleColumn() throws IllegalArgumentException, WrongNumberOfMarblesException {
        int nRows = 5, nColumns = 4;
        Market market = new Market(nRows, nColumns, test21marbles);
        MarbleColour[][] oldMatrix = market.getMarbleMatrix();
        MarbleColour oldOutMarble = market.getOutMarble();
        int chosenWrongColumn = 5;
        assertThrows(IllegalArgumentException.class, () -> market.fetchMarbleColumn(chosenWrongColumn));
        int chosenColumn = 3;
        MarbleColour[] obtainedMarbles = market.fetchMarbleColumn(chosenColumn);
        assertEquals(nRows, obtainedMarbles.length);
        for (int i = 0; i < nRows; i++) {
            assertEquals(oldMatrix[i][chosenColumn], obtainedMarbles[i]);
        }
        assertEquals(oldMatrix[0][chosenColumn], market.getOutMarble());
        for (int i = 0; i < nRows - 1; i++) {
            assertEquals(oldMatrix[i+1][chosenColumn], market.getMarbleMatrix()[i][chosenColumn]);
        }
        assertEquals(oldOutMarble, market.getMarbleMatrix()[nRows-1][chosenColumn]);
    }

    /**
     * Tests the fetch of a specific Marble column in the Market if the column passed as parameter is negative
     * or if it's greater than the number of columns of the Market matrix.
     */
    @Test
    void testFetchMarbleColumnIllegalArgument() throws IllegalArgumentException, WrongNumberOfMarblesException {
        int nRows = 5, nColumns = 4;
        Market market = new Market(nRows, nColumns, test21marbles);
        int chosenWrongColumn = 5;
        assertThrows(IllegalArgumentException.class, () -> market.fetchMarbleColumn(chosenWrongColumn));
        int chosenNegativeColumn = -1;
        assertThrows(IllegalArgumentException.class, () -> market.fetchMarbleColumn(chosenNegativeColumn));
    }

    // Verifies the equality between two Matrices
    static boolean marbleMatricesEquals(MarbleColour[][] matrixA, MarbleColour[][] matrixB) {
        if(matrixA.length != matrixB.length || (matrixA.length != 0 && matrixA[0].length != matrixB[0].length))
            return false;
        for (int i = 0; i < matrixA.length; i++) {
            for (int j = 0; j < matrixA[0].length; j++) {
                if(!matrixA[i][j].equals(matrixB[i][j]))
                    return false;
            }
        }
        return true;
    }

}